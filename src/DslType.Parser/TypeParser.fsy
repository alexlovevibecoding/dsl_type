%{
open DslType
%}

%start main
%type <Program> main

%token TYPE REC LBRACE RBRACE LPAREN RPAREN LANGLE RANGLE DOT PIPE EQUALS COLON SEMICOLON COMMA
%token <string> IDENT
%token UNIT BOOL INT FLOAT STRING
%token EOF
%%
main:
    decls EOF                        { { Declarations = $1 } }

decls:
    /* empty */                      { [] }
  | type_decl decls                  { $1 :: $2 }

type_decl:
    TYPE IDENT type_params_opt EQUALS type_expr SEMICOLON
                                      { { Name = $2; TypeParams = $3; Body = $5 } }

type_params_opt:
    LANGLE ident_list RANGLE          { $2 }
  | /* empty */                      { [] }

ident_list:
    IDENT COMMA ident_list            { $1 :: $3 }
  | IDENT                            { [$1] }

type_expr:
    REC IDENT DOT type_expr           { TypeExpr.Rec (RecBinding.Single ($2, $4)) }
  | REC LPAREN ident_list RPAREN DOT LBRACE rec_body_list RBRACE
                                      { TypeExpr.Rec (RecBinding.Multi ($3, $7)) }
  | non_rec_type                     { $1 }

non_rec_type:
    sum_type                          { $1 }
  | type_expr_app                    { $1 }

sum_type:
    PIPE variant sum_tail             { TypeExpr.Sum ($2 :: $3) }
  | variant PIPE variant sum_tail     { TypeExpr.Sum ($1 :: $3 :: $4) }

sum_tail:
    PIPE variant sum_tail             { $2 :: $3 }
  | /* empty */                      { [] }

variant:
    IDENT variant_payload_opt         { { Name = $1; Payload = $2 } }

variant_payload_opt:
    LPAREN payload_type_list RPAREN   { VariantPayload.TuplePayload $2 }
  | LBRACE field_list RBRACE          { VariantPayload.RecordPayload $2 }
  | /* empty */                      { VariantPayload.NoPayload }

payload_type_list:
    type_expr                         { [$1] }
  | type_expr COMMA payload_type_list { $1 :: $3 }

rec_body_list:
    rec_body rec_body_list            { $1 :: $2 }
  | rec_body                         { [$1] }

rec_body:
    IDENT EQUALS type_expr SEMICOLON  { { Name = $1; Body = $3 } }

type_expr_app:
    type_expr_atom type_args_opt      { match $2 with | None -> $1 | Some args -> TypeExpr.TypeApp ($1, args) }

type_args_opt:
    LANGLE type_arg_list RANGLE       { Some $2 }
  | /* empty */                      { None }

type_arg_list:
    type_expr                         { [$1] }
  | type_expr COMMA type_arg_list     { $1 :: $3 }

type_expr_atom:
    primitive_type                    { TypeExpr.Primitive $1 }
  | IDENT                             { TypeExpr.Identifier $1 }
  | LBRACE field_list RBRACE          { TypeExpr.Record $2 }
  | LPAREN type_expr COMMA tuple_tail RPAREN
                                      { TypeExpr.Tuple ($2 :: $4) }
  | LPAREN type_expr RPAREN           { $2 }

tuple_tail:
    type_expr                         { [$1] }
  | type_expr COMMA tuple_tail        { $1 :: $3 }

field_list:
    field_decl field_list_cont        { $1 :: $2 }

field_list_cont:
    SEMICOLON field_list_cont_nonempty { $2 }
  | /* empty */                      { [] }

field_list_cont_nonempty:
    field_decl field_list_cont        { $1 :: $2 }
  | /* empty */                      { [] }

field_decl:
    IDENT COLON type_expr             { { Name = $1; Type = $3 } }

primitive_type:
    UNIT                              { PrimitiveType.Unit }
  | BOOL                              { PrimitiveType.Bool }
  | INT                               { PrimitiveType.Int }
  | FLOAT                             { PrimitiveType.Float }
  | STRING                            { PrimitiveType.String }

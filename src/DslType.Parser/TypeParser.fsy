%{
open DslType
%}

%start main
%type <Program> main

%token TYPE FN REC LBRACE RBRACE LPAREN RPAREN LANGLE RANGLE DOT PIPE PIPEGT EQUALS COLON SEMICOLON COMMA
%token <string> IDENT
%token UNIT BOOL INT FLOAT DATE DATETIME GUID BYTE SBYTE INT16 INT32 INT64 UINT16 UINT32 UINT64 DECIMAL CHAR STRING
%token EOF
%%
main:
    decls EOF                        { { Declarations = $1 } }

decls:
    /* empty */                      { [] }
  | decl decls                       { $1 :: $2 }

decl:
    type_decl                        { Declaration.Type $1 }
  | fn_decl                          { Declaration.Function $1 }

type_decl:
    TYPE IDENT type_params_opt EQUALS type_expr SEMICOLON
                                      { { Name = $2; TypeParams = $3; Body = $5 } }

fn_decl:
    FN IDENT LPAREN param_list_opt RPAREN COLON type_expr SEMICOLON
                                      { { Name = $2; Parameters = $4; ReturnType = $7 } }

param_list_opt:
    param_list                        { $1 }
  | /* empty */                      { [] }

param_list:
    param_decl COMMA param_list       { $1 :: $3 }
  | param_decl                       { [$1] }

param_decl:
    IDENT COLON type_expr             { { Name = $1; Type = $3 } }

type_params_opt:
    LANGLE ident_list RANGLE          { $2 }
  | /* empty */                      { [] }

ident_list:
    IDENT COMMA ident_list            { $1 :: $3 }
  | IDENT                            { [$1] }

type_expr:
    REC IDENT DOT type_expr           { TypeExpr.Rec (RecBinding.Single ($2, $4)) }
  | REC LPAREN ident_list RPAREN DOT LBRACE rec_body_list RBRACE
                                      { TypeExpr.Rec (RecBinding.Multi ($3, $7)) }
  | non_rec_type                     { $1 }

non_rec_type:
    sum_type                          { $1 }
  | pipe_expr                        { $1 }

pipe_expr:
    pipe_expr PIPEGT type_expr_app    {
                                        let combine left right =
                                            match left with
                                            | TypeExpr.Pipeline (subject, steps) -> TypeExpr.Pipeline (subject, steps @ [right])
                                            | other -> TypeExpr.Pipeline (other, [right])

                                        combine $1 $3
                                      }
  | type_expr_app                    { $1 }

sum_type:
    PIPE variant sum_tail             { TypeExpr.Sum ($2 :: $3) }
  | variant PIPE variant sum_tail     { TypeExpr.Sum ($1 :: $3 :: $4) }

sum_tail:
    PIPE variant sum_tail             { $2 :: $3 }
  | /* empty */                      { [] }

variant:
    IDENT variant_payload_opt         { { Name = $1; Payload = $2 } }

variant_payload_opt:
    LPAREN payload_type_list RPAREN   { VariantPayload.TuplePayload $2 }
  | LBRACE field_list RBRACE          { VariantPayload.RecordPayload $2 }
  | /* empty */                      { VariantPayload.NoPayload }

payload_type_list:
    type_expr                         { [$1] }
  | type_expr COMMA payload_type_list { $1 :: $3 }

rec_body_list:
    rec_body rec_body_list            { $1 :: $2 }
  | rec_body                         { [$1] }

rec_body:
    IDENT EQUALS type_expr SEMICOLON  { { Name = $1; Body = $3 } }

type_expr_app:
    type_expr_atom type_args_opt      { match $2 with | None -> $1 | Some args -> TypeExpr.TypeApp ($1, args) }

type_args_opt:
    LANGLE type_arg_list RANGLE       { Some $2 }
  | /* empty */                      { None }

type_arg_list:
    type_expr                         { [$1] }
  | type_expr COMMA type_arg_list     { $1 :: $3 }

type_expr_atom:
    primitive_type                    { TypeExpr.Primitive $1 }
  | IDENT                             { TypeExpr.Identifier $1 }
  | LBRACE field_list RBRACE          { TypeExpr.Record $2 }
  | LPAREN type_expr COMMA tuple_tail RPAREN
                                      { TypeExpr.Tuple ($2 :: $4) }
  | LPAREN type_expr RPAREN           { $2 }

tuple_tail:
    type_expr                         { [$1] }
  | type_expr COMMA tuple_tail        { $1 :: $3 }

field_list:
    field_decl field_list_cont        { $1 :: $2 }

field_list_cont:
    SEMICOLON field_list_cont_nonempty { $2 }
  | /* empty */                      { [] }

field_list_cont_nonempty:
    field_decl field_list_cont        { $1 :: $2 }
  | /* empty */                      { [] }

field_decl:
    IDENT COLON type_expr             { { Name = $1; Type = $3 } }

primitive_type:
    UNIT                              { PrimitiveType.Unit }
  | BOOL                              { PrimitiveType.Bool }
  | INT                               { PrimitiveType.Int }
  | FLOAT                             { PrimitiveType.Float }
  | DATE                              { PrimitiveType.Date }
  | DATETIME                          { PrimitiveType.DateTime }
  | GUID                              { PrimitiveType.Guid }
  | BYTE                              { PrimitiveType.Byte }
  | SBYTE                             { PrimitiveType.SByte }
  | INT16                             { PrimitiveType.Int16 }
  | INT32                             { PrimitiveType.Int32 }
  | INT64                             { PrimitiveType.Int64 }
  | UINT16                            { PrimitiveType.UInt16 }
  | UINT32                            { PrimitiveType.UInt32 }
  | UINT64                            { PrimitiveType.UInt64 }
  | DECIMAL                           { PrimitiveType.Decimal }
  | CHAR                              { PrimitiveType.Char }
  | STRING                            { PrimitiveType.String }
